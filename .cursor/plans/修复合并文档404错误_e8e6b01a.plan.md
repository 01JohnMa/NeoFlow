---
name: 修复合并文档404错误
overview: 修复照明系统合并上传时文档不存在的问题，主要原因是 `get_merge_template_info` 异常导致文档记录未创建，但前端仍用返回的 document_id 查询。
todos:
  - id: enhance-logging
    content: 在 get_merge_template_info 和 get_template_with_details 中添加详细日志
    status: pending
  - id: fix-error-handling
    content: 修复 process_merge_documents 的错误处理，失败时抛出异常
    status: pending
---

# 修复合并文档404错误

## 问题根因

```
get_merge_template_info 异常(0) → process_merge 返回 success=False 但仍带 document_id 
→ create_document 未执行 → 前端用无效 ID 查询 → 404
```

## 修复步骤

### 1. 增强 `get_merge_template_info` 日志和健壮性

文件：[services/template_service.py](services/template_service.py)

在 `get_merge_template_info` 方法中添加分步日志，定位具体失败点：

```python
async def get_merge_template_info(self, template_id: str) -> Optional[Dict[str, Any]]:
    try:
        logger.debug(f"开始获取合并模板信息: {template_id}")
        
        # 获取主模板
        template = await self.get_template_with_details(template_id)
        if not template:
            logger.warning(f"主模板不存在: {template_id}")
            return None
        
        logger.debug(f"主模板获取成功: {template.get('name')}, process_mode={template.get('process_mode')}")
        
        if template.get("process_mode") != "merge":
            return template
        
        # 获取合并规则
        merge_rules = template.get("template_merge_rules", [])
        logger.debug(f"合并规则数量: {len(merge_rules) if merge_rules else 0}")
        
        if not merge_rules:
            logger.warning(f"模板 {template_id} 没有合并规则")
            return template
        
        merge_rule = merge_rules[0]
        sub_a_id = merge_rule.get("sub_template_a_id")
        sub_b_id = merge_rule.get("sub_template_b_id")
        logger.debug(f"子模板ID: A={sub_a_id}, B={sub_b_id}")
        
        # 获取子模板详情
        if sub_a_id:
            template["sub_template_a"] = await self.get_template_with_details(sub_a_id)
            logger.debug(f"子模板A获取: {'成功' if template.get('sub_template_a') else '失败'}")
        
        if sub_b_id:
            template["sub_template_b"] = await self.get_template_with_details(sub_b_id)
            logger.debug(f"子模板B获取: {'成功' if template.get('sub_template_b') else '失败'}")
        
        return template
    except Exception as e:
        logger.error(f"获取合并模板信息失败: {type(e).__name__}: {e}")
        import traceback
        logger.error(f"堆栈: {traceback.format_exc()}")
        return None
```

### 2. 修复 `process_merge_documents` 错误处理

文件：[api/routes/documents/process.py](api/routes/documents/process.py)

当 `result.get("success")` 为 False 时，抛出业务异常而不是返回带有无效 document_id 的响应：

```python
# 在 process_merge_documents 函数中，调用 ocr_workflow.process_merge 后：
if not result.get("success"):
    error_msg = result.get("error", "合并处理失败")
    logger.error(f"合并处理失败: {error_msg}")
    raise BusinessException(
        error_code="MERGE_FAILED",
        message=error_msg,
        status_code=500
    )
```

### 3. 增强 `get_template_with_details` 健壮性

文件：[services/template_service.py](services/template_service.py)

添加更详细的错误日志：

```python
async def get_template_with_details(self, template_id: str) -> Optional[Dict[str, Any]]:
    try:
        result = self._get_client().table("document_templates").select(
            "*, template_fields(*), template_examples(*), template_merge_rules!template_merge_rules_template_id_fkey(*)"
        ).eq("id", template_id).execute()
        
        if not result.data:
            logger.debug(f"模板不存在: {template_id}")
            return None
        
        template = result.data[0]
        # ... 排序逻辑 ...
        return template
    except Exception as e:
        logger.error(f"获取模板详情失败 [{template_id}]: {type(e).__name__}: {e}")
        raise  # 向上抛出，让调用者处理
```

## 预期效果

- 详细日志帮助定位具体失败点
- 合并失败时返回明确错误而非让前端查询无效 ID
- 异常信息更完整，包含异常类型和堆栈