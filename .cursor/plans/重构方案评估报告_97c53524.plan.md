---
name: 重构方案评估报告
overview: 对 rebuild.md 中的重构优化方案进行全面评估，确认问题诊断准确性，并提出改进建议和风险补充。
todos:
  - id: check-refs
    content: 检查 prompt_config.py 的引用情况，确认可以安全删除
    status: completed
  - id: phase1
    content: 第一阶段：删除重复的 Prompt 配置文件
    status: completed
  - id: phase2
    content: 第二阶段：创建统一异常体系 (api/exceptions.py)
    status: completed
  - id: phase3
    content: 第三阶段：实现认证依赖注入 (api/dependencies/auth.py)
    status: completed
  - id: phase4
    content: 第四阶段：拆分 documents.py 为多个模块
    status: completed
  - id: phase5
    content: 第五阶段：统一表格映射到 supabase_service
    status: completed
---

# 重构方案评估报告

## 一、问题诊断验证

### 已确认的问题

| 问题 | 状态 | 验证结果 |

|------|------|----------|

**1. Prompt 配置重复**

- **已确认** - `prompt_config.py` (116行) 与 `config/prompts.py` (125行) 存在重复
- 但注意：两者内容**不完全相同**
  - 变量名差异：`TEXTREPORTPROMPT` vs `TEXTREPORT_PROMPT`
  - `config/prompts.py` 包含更详细的示例输出和更新的规则
- 建议：保留 `config/prompts.py`（更完整），删除根目录版本

**2. 路由层职责过重**

- **已确认** - `api/routes/documents.py` 共 865 行，包含：
  - 辅助函数（第 24-61 行）
  - 12 个 API 端点
  - 后台任务函数 `process_document_task`（第 230-276 行）
  - 3 个 Pydantic 模型（第 651-666 行）

**3. JWT 认证逻辑重复**

- **已确认** - `extract_token_and_user_id()` 在以下端点重复调用：
  - `/upload`、`/{id}/status`、`/{id}/result`、`/{id}/download`
  - `/`（列表）、`/{id}`（删除）、`/{id}/validate`、`/{id}/rename`、`/{id}/reject`

**4. 表格映射逻辑重复**

- **已确认** - `table_map` 定义出现在：
  - `documents.py:359-367`
  - `documents.py:710-716`
  - 同时 `supabase_service.py` 中 `get_extraction_result()` 方法已有类似映射

**5-11. 其他问题** - 均为合理建议

---

## 二、方案优点

1. **问题定位精准** - 每个问题都指出了具体文件和行号
2. **分阶段规划合理** - 从低风险（清理重复）到高风险（路由拆分）
3. **工作量估计合理** - 8-12 小时符合实际
4. **风险意识到位** - 提出了备份和逐步验证的策略

---

## 三、建议改进

### 3.1 删除 prompt_config.py 前需检查引用

```bash
# 执行前请先检查
rg "from prompt_config" --type py
rg "import prompt_config" --type py
```

当前 `prompt_config.py` 可能被以下位置引用：

- `agents/workflow.py`（需确认）

### 3.2 路由拆分方案细化

原方案的拆分建议可行，但建议调整为：

```
api/routes/documents/
├── __init__.py        # 路由聚合
├── upload.py          # 上传 (1个端点)
├── process.py         # 处理 + 后台任务 (2个端点 + task)
├── query.py           # 状态/结果/列表/下载 (4个端点)
├── review.py          # 审核/重命名/打回 (3个端点)
├── schemas.py         # Pydantic 模型
└── helpers.py         # 辅助函数 (文件操作等)
```

### 3.3 依赖注入方案增强

原方案：

```python
async def get_current_user(authorization: str = Header(...)) -> User:
```

建议增强为：

```python
# api/dependencies/auth.py
from pydantic import BaseModel

class CurrentUser(BaseModel):
    user_id: str
    token: str
    client: Client  # Supabase user client

async def get_current_user(authorization: str = Header(...)) -> CurrentUser:
    """解析 JWT 并返回用户信息和已配置 RLS 的 client"""
    token, user_id = extract_token_and_user_id(authorization)
    if not token or not user_id:
        raise HTTPException(status_code=401, detail="需要登录")
    user_client = supabase_service.get_user_client(token)
    return CurrentUser(user_id=user_id, token=token, client=user_client)
```

这样可以避免每个端点重复调用 `supabase_service.get_user_client(token)`。

### 3.4 表格映射统一到 supabase_service

在 `supabase_service.py` 中添加：

```python
# 类常量
TABLE_MAP = {
    "测试单": "inspection_reports",
    "inspection_report": "inspection_reports",
    "快递单": "expresses",
    "express": "expresses",
    "抽样单": "sampling_forms",
    "sampling_form": "sampling_forms"
}

def get_table_name(self, document_type: str) -> Optional[str]:
    """根据文档类型获取表名"""
    return self.TABLE_MAP.get(document_type)
```

### 3.5 异常类设计建议

```python
# api/exceptions.py
from fastapi import HTTPException

class AppException(HTTPException):
    """基础业务异常"""
    def __init__(self, code: str, detail: str, status_code: int = 400):
        super().__init__(status_code=status_code, detail=detail)
        self.code = code

class AuthenticationError(AppException):
    def __init__(self, detail: str = "需要登录"):
        super().__init__(code="AUTH_REQUIRED", detail=detail, status_code=401)

class DocumentNotFoundError(AppException):
    def __init__(self, document_id: str):
        super().__init__(
            code="DOC_NOT_FOUND", 
            detail=f"文档不存在或无权访问: {document_id}", 
            status_code=404
        )

class ProcessingError(AppException):
    def __init__(self, detail: str):
        super().__init__(code="PROCESSING_FAILED", detail=detail, status_code=500)
```

---

## 四、风险补充

| 风险 | 等级 | 缓解措施 |

|------|------|----------|

| Prompt 删除后遗漏引用 | 中 | 执行前全局搜索所有引用 |

| 依赖注入破坏现有测试 | 低 | 编写端点测试用例后再改 |

| 路由拆分后循环导入 | 中 | 使用延迟导入或提取公共模块 |

| 后台任务无法访问拆分后的函数 | 中 | 将 `process_document_task` 放在 `process.py` 中 |

---

## 五、推荐执行顺序

1. **第一阶段**（安全，可立即执行）

   - 检查 `prompt_config.py` 引用
   - 删除重复文件

2. **第二阶段**（中等风险）

   - 创建 `api/exceptions.py`
   - 更新 `api/main.py` 全局异常处理

3. **第三阶段**（需要仔细测试）

   - 创建 `api/dependencies/auth.py`
   - 逐个端点迁移认证逻辑

4. **第四阶段**（最高风险）

   - 拆分 `documents.py` 为多个文件
   - 每拆分一个文件后立即测试

---

## 六、OCR 服务分离前瞻性设计（后续阶段）

根据您的需求，后续需要将 OCR 服务部署到 GPU 服务器，并支持多实例扩展。以下是通信方式建议和当前重构时需要预留的接口设计：

### 6.1 通信方式对比与建议

| 方式 | 优点 | 缺点 | 适用场景 |

|------|------|------|----------|

| **HTTP API** | 简单、通用、易调试 | 延迟较高、序列化开销 | 中小规模、跨语言 |

| **gRPC** | 高性能、强类型、流式传输 | 需要学习、调试复杂 | 高并发、大文件传输 |

| **消息队列** | 异步解耦、削峰填谷、可靠投递 | 架构复杂、需要运维 | 高并发、容错要求高 |

**推荐方案：HTTP API + 异步任务队列（Redis/Celery）**

理由：

- OCR 本身是 CPU/GPU 密集型任务，HTTP 延迟可接受
- 消息队列可以实现任务排队和负载均衡
- 支持多实例 worker 消费任务，天然支持水平扩展
- 技术栈成熟，与现有 FastAPI 架构兼容

### 6.2 当前重构时的预留设计

在本次重构中，建议对 `ocr_service.py` 进行抽象，以便后续无缝切换为远程调用：

```python
# services/ocr_service.py
from abc import ABC, abstractmethod

class OCRServiceBase(ABC):
    """OCR 服务抽象基类"""
    
    @abstractmethod
    async def recognize(self, file_path: str) -> dict:
        """执行 OCR 识别"""
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """健康检查"""
        pass

class LocalOCRService(OCRServiceBase):
    """本地 PaddleOCR 实现（当前）"""
    ...

class RemoteOCRService(OCRServiceBase):
    """远程 OCR 服务实现（后续）"""
    def __init__(self, base_url: str):
        self.base_url = base_url
    
    async def recognize(self, file_path: str) -> dict:
        # 上传文件到远程服务并获取结果
        ...
```

### 6.3 GPU 服务器 OCR 服务架构建议

```
┌─────────────────────────────────────────────────────────┐
│                    主服务器（CPU）                       │
│  ┌─────────┐    ┌─────────┐    ┌─────────────────────┐ │
│  │ FastAPI │───▶│  Redis  │◀───│ 任务结果回调/轮询   │ │
│  └─────────┘    └────┬────┘    └─────────────────────┘ │
└──────────────────────┼──────────────────────────────────┘
                       │ 任务队列
        ┌──────────────┼──────────────┐
        ▼              ▼              ▼
┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│ OCR Worker 1  │ │ OCR Worker 2  │ │ OCR Worker N  │
│ (GPU Server)  │ │ (GPU Server)  │ │ (GPU Server)  │
│ PaddleOCR     │ │ PaddleOCR     │ │ PaddleOCR     │
└───────────────┘ └───────────────┘ └───────────────┘
```

### 6.4 后续分离时的改动范围

如果本次重构采用抽象接口，后续分离只需：

1. 实现 `RemoteOCRService` 类
2. 修改 `config/settings.py` 添加 OCR 服务地址配置
3. 修改服务初始化逻辑，根据配置选择本地或远程实现
4. 部署独立的 OCR Worker 服务

**无需修改**：路由层、业务逻辑、数据库操作

---

## 七、总体评价

- **方案质量**：优秀，问题诊断准确，规划合理
- **可执行性**：高，分阶段设计降低了风险
- **OCR 分离准备**：建议在重构时对 `ocr_service.py` 进行接口抽象，预留扩展能力
- **建议**：按上述改进建议执行，每阶段完成后进行 API 测试验证