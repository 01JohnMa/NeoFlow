# 项目构建 PRD 经验总结

> 基于 NeoFlow 智能文档处理平台的实施方案和重构经验提炼，用于指导未来项目构建

---

## 一、MVP 先行原则

### 1.1 核心理念

**先跑通再优化，先验证再扩展**

| 阶段 | 目标 | 产出 |
|------|------|------|
| MVP 验证 | 核心功能可用 | 最小可运行代码 |
| 工程化 | 结构规范化 | 分层架构代码 |
| 优化迭代 | 性能+可维护性 | 重构后的代码 |

### 1.2 MVP 阶段应验证的内容

- [ ] 核心业务逻辑能否跑通（本项目：OCR识别 + LLM提取）
- [ ] 依赖的外部服务是否可用（本项目：PaddleOCR、OpenAI API）
- [ ] 输入输出格式是否明确（本项目：图片/PDF → JSON结构化数据）

### 1.3 MVP 代码特征

```
✅ 允许：
- 单文件实现
- 硬编码配置
- 简单的错误处理
- print 调试

❌ 不需要：
- 完善的项目结构
- 单元测试
- 异常体系
- 日志系统
```

---

## 二、分层架构设计

### 2.1 推荐的项目结构

```
project/
├── api/                    # 接口层 - 处理HTTP请求
│   ├── main.py            # FastAPI入口
│   ├── routes/            # 路由模块（按功能拆分）
│   │   ├── __init__.py
│   │   ├── documents/     # 复杂路由拆为子目录
│   │   │   ├── upload.py
│   │   │   ├── query.py
│   │   │   └── schemas.py
│   │   └── health.py
│   ├── dependencies/      # 依赖注入
│   │   └── auth.py
│   └── exceptions.py      # 统一异常定义
│
├── services/              # 服务层 - 业务逻辑
│   ├── __init__.py
│   ├── ocr_service.py
│   └── database_service.py
│
├── agents/                # 智能体层（如使用LangGraph）
│   └── workflow.py
│
├── config/                # 配置层
│   ├── settings.py       # 环境变量管理
│   └── prompts.py        # Prompt模板
│
├── models/               # 数据模型（可选）
└── utils/                # 工具函数
```

### 2.2 各层职责划分

| 层级 | 职责 | 不应包含 |
|------|------|----------|
| **API 层** | 参数校验、路由分发、响应格式化 | 业务逻辑、数据库操作 |
| **Service 层** | 业务逻辑、事务处理、外部服务调用 | HTTP处理、路由定义 |
| **Agent 层** | 工作流编排、LLM调用 | 数据持久化 |
| **Config 层** | 配置管理、环境变量 | 业务代码 |

### 2.3 路由文件拆分标准

```
单文件阈值：300行以内
超过300行 → 拆分为目录结构

拆分维度：
- 按功能：upload / query / review
- 按实体：documents / users / reports
```

---

## 三、配置管理规范

### 3.1 配置文件分离

```
.env                 # 敏感配置（gitignore）
.env.example         # 配置模板（提交到git）
config/settings.py   # 配置类定义
```

### 3.2 配置类设计（Pydantic Settings）

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # 分组注释
    # ============ 数据库配置 ============
    DATABASE_URL: str
    
    # ============ LLM配置 ============
    LLM_API_KEY: str
    LLM_MODEL_ID: str = "gpt-4o-mini"  # 默认值
    
    # 派生属性
    @property
    def allowed_extensions_list(self) -> list:
        return self.ALLOWED_EXTENSIONS.split(",")
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### 3.3 配置优先级

```
命令行参数 > 环境变量 > .env文件 > 代码默认值
```

---

## 四、代码复用与 DRY 原则

### 4.1 识别重复代码的信号

| 信号 | 示例 | 解决方案 |
|------|------|----------|
| 相同代码出现 2+ 次 | JWT解析在每个端点重复 | 抽取为依赖注入 |
| 相似映射逻辑 | 文档类型→表名映射重复 | 定义为类常量 |
| 配置文件重复 | prompt_config.py 与 config/prompts.py | 删除一个，统一引用 |

### 4.2 抽象层次选择

```
❌ 过度抽象：
- 只用一次的工具函数
- 过早的接口抽象

✅ 合适抽象：
- 重复3次以上的逻辑
- 明确会扩展的功能点
- 外部服务调用（便于mock测试）
```

### 4.3 本项目抽象示例

```python
# 表映射统一定义（而非分散在多处）
class SupabaseService:
    TABLE_MAP = {
        "测试单": "inspection_reports",
        "快递单": "expresses",
        "抽样单": "sampling_forms"
    }
    
    def get_table_name(self, doc_type: str) -> str:
        return self.TABLE_MAP.get(doc_type)
```

---

## 五、依赖注入模式

### 5.1 FastAPI Depends 使用场景

| 场景 | 适用 | 不适用 |
|------|------|--------|
| 认证校验 | ✅ | |
| 数据库会话 | ✅ | |
| 简单参数转换 | | ❌ 用参数默认值 |
| 复杂业务逻辑 | | ❌ 放到 Service 层 |

### 5.2 认证依赖标准实现

```python
# api/dependencies/auth.py
from fastapi import Header, Depends

class CurrentUser(BaseModel):
    user_id: str
    token: str

async def get_current_user(
    authorization: str = Header(...)
) -> CurrentUser:
    """必须登录"""
    token, user_id = parse_jwt(authorization)
    if not user_id:
        raise AuthenticationError()
    return CurrentUser(user_id=user_id, token=token)

async def get_optional_user(...) -> Optional[CurrentUser]:
    """可选登录"""
    ...

# 使用方式
@router.get("/protected")
async def endpoint(user: CurrentUser = Depends(get_current_user)):
    ...
```

---

## 六、异常处理体系

### 6.1 异常分层设计

```
AppException (基类)
├── AuthenticationError (401)
├── AuthorizationError (403)
├── NotFoundError (404)
│   ├── DocumentNotFoundError
│   └── FileNotFoundError
├── ValidationError (400)
│   ├── FileTypeError
│   └── FileSizeError
└── ProcessingError (500)
    ├── DatabaseError
    └── ExternalServiceError
```

### 6.2 异常类标准结构

```python
class AppException(HTTPException):
    def __init__(self, code: str, detail: str, status_code: int):
        super().__init__(status_code=status_code, detail=detail)
        self.code = code  # 错误码，供前端判断

# 使用
raise DocumentNotFoundError(document_id)
# 返回: {"error": "文档不存在: xxx", "code": "DOC_NOT_FOUND", "status_code": 404}
```

### 6.3 全局异常处理器

```python
@app.exception_handler(AppException)
async def app_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.detail, "code": exc.code}
    )
```

---

## 七、服务层设计模式

### 7.1 单例模式应用

```python
class OCRService:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    @classmethod
    def reset_singleton(cls):
        """测试时重置（重要！）"""
        cls._instance = None

# 导出单例
ocr_service = OCRService()
```

### 7.2 异步初始化模式

```python
class Service:
    async def initialize(self):
        """应用启动时调用"""
        ...
    
    async def close(self):
        """应用关闭时调用"""
        ...

# main.py
@asynccontextmanager
async def lifespan(app):
    await service.initialize()
    yield
    await service.close()
```

---

## 八、数据库设计原则

### 8.1 表结构设计

```sql
-- 主表：通用字段
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    status VARCHAR(20) DEFAULT 'uploaded',
    document_type VARCHAR(50),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 子表：按业务类型分表
CREATE TABLE inspection_reports (
    id UUID PRIMARY KEY,
    document_id UUID REFERENCES documents(id),
    -- 业务字段...
    is_validated BOOLEAN DEFAULT FALSE,
    validated_at TIMESTAMPTZ
);
```

### 8.2 RLS（行级安全）策略

```sql
-- 用户只能看自己的数据
CREATE POLICY "user_isolation" ON documents
    FOR ALL USING (auth.uid() = user_id);

-- 管理员可看所有
CREATE POLICY "admin_access" ON documents
    FOR SELECT USING (
        auth.jwt() ->> 'role' = 'admin'
    );
```

---

## 九、重构时机判断

### 9.1 何时重构

| 信号 | 阈值 | 行动 |
|------|------|------|
| 单文件行数 | > 300行 | 拆分模块 |
| 重复代码 | 出现3次 | 抽取函数/类 |
| 相同配置 | 2处定义 | 统一到一处 |
| 难以测试 | 无法mock | 抽象接口 |

### 9.2 重构安全原则

```
1. 先写测试，再重构
2. 小步提交，每步验证
3. 保留备份文件（xxx_backup.py）
4. 重构完成后删除备份
```

### 9.3 重构顺序（风险从低到高）

```
1. 删除重复/无用代码 ← 最安全
2. 创建新模块（不改旧代码）
3. 抽取公共函数/类
4. 拆分大文件
5. 改变调用关系 ← 风险最高
```

---

## 十、部署与环境

### 10.1 环境分离

```
开发环境：DEBUG=true, 热重载
测试环境：模拟数据库, Mock外部服务
生产环境：DEBUG=false, 真实密钥
```

### 10.2 Docker 化标准

```dockerfile
# 多阶段构建
FROM python:3.10-slim as builder
COPY requirements.txt .
RUN pip install --user -r requirements.txt

FROM python:3.10-slim
COPY --from=builder /root/.local /root/.local
COPY . .
CMD ["uvicorn", "api.main:app", "--host", "0.0.0.0"]
```

### 10.3 服务编排要点

```yaml
services:
  app:
    depends_on:
      db:
        condition: service_healthy  # 等待依赖健康
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
```

---

## 十一、项目启动 Checklist

### 11.1 PRD 阶段

- [ ] 明确核心用户场景（1-3个）
- [ ] 定义输入输出格式
- [ ] 列出技术依赖和风险点
- [ ] 估算 MVP 开发周期

### 11.2 MVP 阶段

- [ ] 单文件实现核心功能
- [ ] 验证外部服务可用性
- [ ] 确认数据模型设计
- [ ] 测试端到端流程

### 11.3 工程化阶段

- [ ] 建立分层目录结构
- [ ] 配置管理（.env + Settings类）
- [ ] 统一异常体系
- [ ] 依赖注入（认证等）
- [ ] 日志配置

### 11.4 优化阶段

- [ ] 识别并消除重复代码
- [ ] 拆分过大的文件
- [ ] 添加单元测试
- [ ] 性能优化（必要时）

---

## 十二、经验教训总结

### 12.1 成功实践

| 实践 | 效果 |
|------|------|
| MVP 先行 | 快速验证，减少返工 |
| Supabase 本地部署 | 完全掌控数据，开发调试便利 |
| 分阶段重构 | 降低风险，可控推进 |
| 统一异常体系 | 前后端错误处理一致 |

### 12.2 避免的坑

| 问题 | 原因 | 解决 |
|------|------|------|
| 配置文件重复 | 早期未规划 | 一开始就统一到 config/ |
| 路由文件过大 | 功能堆积 | 超300行即拆分 |
| JWT每次重复解析 | 未用依赖注入 | 抽取为 Depends |
| 表映射多处定义 | 复制粘贴 | 定义为服务层常量 |

### 12.3 核心原则

```
1. 先跑通再优化
2. 配置集中管理
3. 重复代码 = 技术债
4. 分层清晰，职责单一
5. 小步提交，持续验证
```

---

## 附录：快速参考

### A. 文件命名规范

```
snake_case.py          # Python文件
PascalCase             # 类名
snake_case             # 函数/变量
UPPER_CASE             # 常量
```

### B. 提交信息格式

```
类型 | 描述
feat | 新功能
fix  | 修复bug
refactor | 重构
docs | 文档
```

### C. 代码注释模板

```python
def function(param: str) -> Dict:
    """
    一句话描述功能
    
    Args:
        param: 参数说明
        
    Returns:
        返回值说明
        
    Raises:
        SomeError: 异常情况说明
    """
```
